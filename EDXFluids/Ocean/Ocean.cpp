#include "Ocean.h"
#include "Math/EDXMath.h"
#include "Math/FFT.h"

#include <ppl.h>
using namespace concurrency;

namespace EDX
{
	void Ocean::Initialize()
	{
		miMapDimFFT = 128;
		mfPatchSize =500.0f;
		mfWindSpeed = 600.0f;
		mfWaveAmplitude = 1.0f;
		mfChoppyScale = 1.3f;
		mfTimeScale = 0.8f;
		mvWindDir = Vector2(0.8f, 0.6f);
 		mfAmpFactor = 1.0f;
// 		mfSampFactor = 1.35f;
// 		mfSlopeVariance = 0.02f;

		mavH0.Init(Vector2i(miMapDimFFT, miMapDimFFT));
		mavHt.Init(Vector2i(miMapDimFFT, miMapDimFFT));
		mavTroppyX.Init(Vector2i(miMapDimFFT, miMapDimFFT));
		mavTroppyZ.Init(Vector2i(miMapDimFFT, miMapDimFFT));
		mafOmega.Init(Vector2i(miMapDimFFT, miMapDimFFT));
		mafHeightData.Init(Vector2i(miMapDimFFT, miMapDimFFT));
		mafTroppyXData.Init(Vector2i(miMapDimFFT, miMapDimFFT));
		mafTroppyZData.Init(Vector2i(miMapDimFFT, miMapDimFFT));

		InitHeightMap();

		miFrameIdx = 0;
	}

	float Ocean::PhillipsSpectrum(const Vector2& vK) const
	{
		float L = mfWindSpeed * mfWindSpeed / float(GRAV_CONST);
		float l = L / 1000.0f;
		float fSqrK = vK.x * vK.x + vK.y * vK.y;
		//D3DXVec2Normalize(&K, &K);
		float fCosK = vK.x * mvWindDir.x + vK.y * mvWindDir.y;

		float fPhillips = mfWaveAmplitude * Math::Exp(-1 / (fSqrK * L * L)) / (fSqrK * fSqrK * fSqrK) * (fCosK * fCosK);

		if(fCosK < 0)
			fPhillips *= 0.07f;

		return fPhillips * Math::Exp(-fSqrK * l * l);
	}

	void Ocean::InitHeightMap()
	{
		//for(auto i = 0; i < iMapDimFFT; i++)
		parallel_for(0, miMapDimFFT, [&](int i)
		{
			Vector2 K;
			K.x = (-miMapDimFFT / 2.0f + i) * (2 * float(Math::EDX_PI) / mfPatchSize);
			//K.x = (i >= (iMapDimFFT / 2) ? i - iMapDimFFT : i) * (2 * D3DX_PI / fPatchSize);
			for(auto j = 0 ; j < miMapDimFFT; j++)
			{
				K.y = (-miMapDimFFT / 2.0f + j) * (2 * float(Math::EDX_PI) / mfPatchSize);
				//K.y = (j >= (iMapDimFFT / 2) ? j - iMapDimFFT : j) * (2 * D3DX_PI / fPatchSize);

				float phil = (K.x == 0 && K.y == 0) ? 0 : Math::Sqrt(PhillipsSpectrum(K));

				mavH0[Vector2i(i, j)].x = float(phil * mRNG.GaussFloat() * 0.7071068f);
				mavH0[Vector2i(i, j)].y = float(phil * mRNG.GaussFloat() * 0.7071068f);
							
				mafOmega[Vector2i(i, j)] = Math::Sqrt(GRAV_CONST * Math::Sqrt(K.x * K.x + K.y * K.y));
			}
		});
	}

	void Ocean::UpdateHeightMap(const Math::FFT& fft, const float fTime)
	{
		//for(auto i = 0; i < iMapDimFFT; i++)
		parallel_for(0, miMapDimFFT, [&](int i)
		{
			for(auto j = 0 ; j < miMapDimFFT; j++)
			{
				const Vector2i vIdx = Vector2i(i, j);
				const Vector2i vInvIdx = Vector2i(miMapDimFFT - 1, miMapDimFFT - 1) - vIdx;

				Vector2 vH0 = mavH0[vIdx] * mfAmpFactor;
				Vector2 vInvH0 = mavH0[vInvIdx] * mfAmpFactor;
				float fOmega = mafOmega[vIdx];

				float fSin, fCos;
				Math::SinCos(fTime * fOmega, fSin, fCos);

				Vector2 vHt = Vector2((vH0.x + vInvH0.x) * fCos - (vH0.y + vInvH0.y) * fSin, (vH0.x - vInvH0.x) * fSin + (vH0.y - vInvH0.y) * fCos);
				mavHt[vIdx] = vHt;

				Vector2 vK = Vector2(vIdx - 0.5f * Vector2(miMapDimFFT, miMapDimFFT)) + Vector2(1e-4f);
				vK = -Math::Normalize(vK);
				mavTroppyX[vIdx].x = -vK.x * vHt.y;
				mavTroppyX[vIdx].y = vK.x * vHt.x;
				mavTroppyZ[vIdx].x = -vK.y * vHt.y;
				mavTroppyZ[vIdx].y = vK.y * vHt.x;
			}
		});

		fft.PerformInverse2D((float*)mavHt.Data(), mafHeightData.ModifiableData());
		fft.PerformInverse2D((float*)mavTroppyX.Data(), mafTroppyXData.ModifiableData());
		fft.PerformInverse2D((float*)mavTroppyZ.Data(), mafTroppyZData.ModifiableData());

		miFrameIdx++;
	}

	Vector3 Ocean::GetVertex(const Vector2i& vIdx) const
	{
		float x = mafTroppyXData[vIdx];
		float y = mafHeightData[vIdx];
		float z = mafTroppyZData[vIdx];

		return Vector3(1.3f * x, y, 1.3f * z);
	}

	void Ocean::GenerateObjMesh() const
	{
		char strFileName[260];
		sprintf_s(strFileName, 260, "../Output/OceanMesh%i.obj", miFrameIdx);

		std::ofstream outFile;
		outFile.open(strFileName);
		assert(outFile.is_open());

		outFile << "# This file is generated by EDXOcean. Please visit www.edxgraphics.com\n" << "\n";

		for(auto y = 0; y < miMapDimFFT; y++)
		{
			for(auto x = 0; x < miMapDimFFT; x++)
			{
				Vector3 vPos = Vector3(x - 0.5f * miMapDimFFT, 0.0f, y - 0.5f * miMapDimFFT);
				Vector3 vOffset = GetVertex(Vector2i(x, y));
				vPos += vOffset;
				outFile << "v" << " " << vPos.x << " " << vPos.y << " " << vPos.z << "\n";
			}
		}

		outFile << "s 1" << "\n";
		for(auto y = 0; y < miMapDimFFT; y++)
		{
			for(auto x = 0; x < miMapDimFFT; x++)
			{
				float fU = x / float(miMapDimFFT);
				float fV = y / float(miMapDimFFT);
				outFile << "vt" << " " << fU << " " << fV << "\n";
			}
		}

		for(auto y = 0; y < miMapDimFFT - 1; y++)
		{
			for(auto x = 0; x < miMapDimFFT - 1; x++)
			{
				int iIdx1 = mafHeightData.LinearIndex(Vector2i(x, y)) + 1;
				int iIdx2 = mafHeightData.LinearIndex(Vector2i(x + 1, y)) + 1;
				int iIdx3 = mafHeightData.LinearIndex(Vector2i(x, y + 1)) + 1;
				int iIdx4 = mafHeightData.LinearIndex(Vector2i(x + 1, y + 1)) + 1;
				outFile << "f" << " "
					<< iIdx1 << "/" << iIdx1 << " "
					<< iIdx3 << "/" << iIdx3 << " "
					<< iIdx2 << "/" << iIdx2 << "\n";
				outFile << "f" << " "
					<< iIdx3 << "/" << iIdx3 << " "
					<< iIdx4 << "/" << iIdx4 << " "
					<< iIdx2 << "/" << iIdx2 << "\n";
			}
		}


		outFile.close();
	}
}